===========================================================================
2020-10-20
Tuesday, October 20, 2020

Started a ChangeLog file to keep track of my daily progress. I will need to
add in issues I have previously come up with and that which are not yet
included here.

I pushed a commit today of GPIO toggling (for the onboard LEDs) which goes
into great detail of each required part.
There are four registers to configure, in addition to configuring the RCC
clock. There are two ways to set or reset a GPIO pin once it is all set up:
by a read/modify/write dance, or with an atomic bit set or reset operation.

For setting up the GPIO (for port D, for the LEDs), this needs to be done:
 Set up the gpio:
1. clock through the RCC_AHB1ENR register.
2. mode through the GPIOD_MODER register.
3. output as push-pull or open-drain through the GPIOD_OTYPER register.
4. port speed through the GPIOD_OSPEEDR register.
5. pull-up or pull-down resistors through the GPIOD_PUPDR register.

For actually using the GPIO as an output there are two ways:
1. Read/modify/write of the GPIOD_ODR Output Data Register
2. Writing to the GPIOD_BSRR Bit Set/Reset Register

Whichever one is used (or available) is chip vendor dependent. These are
both available for STM32F4 chips.

I put the linker script in the testing base directory (with Makefile.inc)
so that all testing programs can use it, instead of having each program
duplicating the linker script.

The program I finished today has links to all the documentation I have used
to make that program. I will end up putting them in this repository.

I added a .gitignore to the testing directory. Not sure if it is best to
use a global one yet, so just this local one for now.

===========================================================================
2020-10-31
Saturday, October 31, 2020

Pushed two commits that import the RetroBSD repo into this project repo.
I also included the zip from the autobuilder so that there is some starting
point that is easily referenced (instead of just a commit id).


The last while I've been trying to get a mips-elf port of gcc, binutils,
and gdb to build the RetroBSD repo (which is mips-based). I had already got
it to work on Ubuntu (through the Windows Subsystem for Linux) by following
the instructions at http://retrobsd.org/wiki/doku.php/doc/toolchain-mips
which took quite a bit of time to go through.

Also, these instructions are made for an old version of gcc, compiled with
another old version of gcc. The newer gcc's are way more pedantic and find
so many more bugs, even small ones, so it has been a challenge. For
instance, one bug I came across was that glibc changed the location of some
defines into a different header, so I had to find out which one it was and
make a patch for it. It's not hard, just tedious and unfulfilling work.


Get first crack at a devel/mips-elf OpenBSD port done. It has gcc 4.8.1 and
binutils 2.27. Many patches were made. 8 for binutils, 19 for gcc.
I based this port on the ports devel/xtensa-elf and devel/arm-none-eabi.
gdb and newlib are not done yet (and maybe never will be).
binutils was the first I got working. It took a while to get gcc to work.

This port is for compiling the original code of RetroBSD on OpenBSD. The
original code targets the PIC32 MIPS-based microcontroller, thus mips-elf.

There are two or three segfaults in the process of building gcc. I have no
reason why, and I haven't investigated. Starting the build over again
allows a bit more progress until there is another segfault. I just kept
restarting it until the build is complete. The segfaults could be due to
running out of memory or something like that. Who knows. gcc is complex.

There are some post-patch and post-install fixes in the devel/avr/gcc
Makefile that need to be used. This will get rid of all the ridiculous
patches for the single space character needed by c++11 for variables.

===========================================================================
2020-11-01
Sunday, November 01, 2020

I started to build DiscoBSD with my new toolchain, but there are quite a
few errors. The main one is (after much investigation into the cause) due
to gcc not passing -msoft-float to the assembler. This caused the assembler
to assemble as -mhard-float. The linker wasn't able to link these two
separate types of objects.

I fixed this by getting a patchset from gcc, which I had to modify, as it
was meant for some newer version of gcc (5?).

I made 4 new patches, and added some more changes to an already existing
patch. That fixed the whole floating-point issue. The userland programs can
be built now. The kernel builds, too. There still is a problem with the
linker overlaying sections of the executable. I haven't researched it yet,
though.

The VirtualMIPS simulator isn't building. Probably due to not having the
libelf package on OpenBSD. I may need to port that library, too. Who knows.

Other problems are: elf2aout, manpages, init_main.c, expr, yacc kconfig
reduce/reduce conflicts, install not working.

I updated the README.md file for tools/openbsd to include how to get
binutils and gcc for the MIPS target.


Now I am trying to get VirtualMIPS to work. Most errors are about specific
types used. I am guessing they are defined in the libelf code.

I have had to (temporarily) hard-code some directory paths in the Makefile
for VirtualMIPS to what OpenBSD uses, such as /usr/local/include instead of
/opt/local/include on Linux.


Some cool things about the name DiscoBSD:
First, 'disco' is Latin for 'I learn' or 'to learn' or 'become aquainted
with' or 'I study, practice'. All of these definitions are quite in line
with the whole purpose of this directed study, which is to do a heck of a
lot of learning about Arm and about Unix and about early BSD.

Second, STM has a 'Discovery' line of demonstration and evauation circuit
boards with STM32F4 microcontrollers. I am targeting the STM32F4DISCOVERY
board with an STM32F407 chip (which does not have an MMU).

Third, it is just a great name. There is a nice ring to it. It has five
letters like 'Retro', and it gives you feelings of the old days in the 70s
when BSD had its beginnings.


Okay, ELF toolchain is needed to get VirtualMIPS to work. It can be used
instead of libelf. I am so glad I do not need to port another library.
ELF toolchain is available as a package on OpenBSD. I updated the README.

For VirtualMIPS, I initially put the pthreads header include into many,
many files. I then figured out that I only needed to have it in the mips.h
file, which is included in all those files. Seems like a better solution.


I got the build system so that it is possible to build RetroBSD (MIPS) on
OpenBSD. The changes were to update byacc to yacc, and add a check for the
mips-elf tools to the build Makefiles. OpenBSD has them installed in the
third-party location /usr/local/bin/mips-elf- .

Note that when I say "RetroBSD" I am talking about the original MIPS code.
"DiscoBSD" will refer to the Arm code/port I am writing.

I found that there is something wrong with elf2aout in that it fails on an
ELF section of type 70000003 in program header 1, from the error message.
I need to learn about the ELF executable file type and the a.out type.


I read about the ELF executable file type in the book Learning Linux Binary
Analysis and in the elf(3) and elf(5) manpages. There is not a lot of info
on it. All my C and Unix books don't really mention anything about it.

I am looking at the differences between the "adb" executables compiled on
OpenBSD, and on Linux (Winbuntu). This is one of the programs that fail to
convert from ELF to a.out by the elf2aout program, with this error:
elf2aout: Program header 1 type 70000003 can't be converted.
The program output of "readelf -aW adb.elf" is what is used to look at elf.

I determined, through using the readelf tool from binutils, that the MIPS
toolchain I made to work on OpenBSD adds a section to the executable called
.MIPS.abiflags, which is not made on the Winbuntu system. I believe this
section is made by the linker. I don't know for sure, but I believe that
this is due to my toolchain using modern versions of the depended-on
libraries, perhaps the BFD library. I found a post on a Clang/LLVM mailing
list that said they needed to add that particular section to MIPS exes.

What I did to fix this problem was add that section to the /DISCARD/ part
at the end of the linker script elf32-mips.ld . The line is:
  /DISCARD/ : { *(.MIPS.abiflags) }
inside the SECTIONS curly braces near the end of the file.

A small diff to fix a big problem.

Now, I am able to build the whole system, and actually run it on OpenBSD!
How I do it is, after the system is built, I go into the tools/virtualmips
directory and run ./pic32 and I get a shell, and I can log in as root
(without a password) and then run any command.

I included a screenshot of RetroBSD booting in the new 'report' directory.

I also noticed that this problem was happening with all linker scripts.
Bootloaders were having problems with overlapping sections due to the
addition of the .MIPS.abiflags section to the executable. I removed that
section from any binary made, by adding the /DISCARD/ line to all linker
scripts.

Found that seven of the target platforms for RetroBSD segfault upon
building init_main.c at the very last line. I can't get a stack trace as
libunwind isn't a part of the mips-elf gcc port I created. These target
platforms are not the popular ones for the MIPS port, so I am going to
leave them alone. The max32 port works, and that is what also works with
the VirtualMIPS simulator, so I will leave it for now.


The libintl library is used by VirtualMIPS. Add check for it on OpenBSD.
I don't think it is needed, but what the heck. Why not.

===========================================================================
2020-11-02
Monday, November 02, 2020

I discovered that there are quite a bit of hardcoded MIPS variables spread
throughout the codebase, mostly in the Makefiles. I will have to clean up
some more of the codebase before I can get started on the Arm port.

The first thing I have noticed is that the variable MACHINE is used for
mips, and I will need to make it set to either mips or arm. I can do
autoselection of build tools and specific kernel code by just using the
MACHINE variable. I have had a hard time finding out where that variable is
defined in OpenBSD (so that I can use a similar place in the build system
for DiscoBSD).


Cool fact: A comment in a Makefile is a comment, except for the odd fact
that if the line ends in a backslash, and that backslash is not escaped
with another backslash, then the comment will continue across multiple
lines. So don't think that a (#) comment is just a comment.


Okay, I'm working on a commit for all the Makefile business to have
multiple target architectures supported in this codebase.

I am temporarily turning off -Werror for now, as the new gcc is showing too
many errors, and I just want the build to be able to finish.


Researched a bit about how NetBSD does cross-compilation with build.sh and
I made a groundbreaking development. I need to introduce a MACHINE_ARCH
variable which will replace what is currently defined for MACHINE.
This will break compatibility with RetroBSD, but this is the right way of
doing it. This is also how OpenBSD does it with the macppc/powerpc arches.
I am glad I held off on that commit that would only add MACHINE.

Going forward, this will be the status of MACHINE{,_ARCH} variables:
MACHINE      specifies the machine hardware platform.
MACHINE_ARCH specifies the machine processor architecture.
For example: MACHINE => pic32 ; MACHINE_ARCH => mips
             MACHINE => stm32 ; MACHINE_ARCH => arm

MACHINE      derives from "uname -m"
MACHINE_ARCH derives from "uname -p"

For right now, the defaults are MACHINE=pic32 and MACHINE_ARCH=mips
The Makefiles use the "?=" instead of just a "=", so they can be redefined
on the command line when gmake is invoked, like this:
  $ MACHINE=stm32 MACHINE_ARCH=arm gmake

Not sure about the arm compiling lines in target.mk. I will refine the
options once I get it to compile for Arm. I copied over the linker script
from the testing directory and named it similar to the mips one. It will
definitely need to be changed.

Thought about if I should amend the Makefiles to also figure out which host
the cross-compilation is being performed on. I have come to the conclusion
that I won't do that, and I will focus my development work on OpenBSD as
the host development platform, and I could get the other OSes working after
I have the Arm port working. I also don't have a dedicated Linux install. I
only currently have the Ubuntu on Windows Subsystem for Linux (Winbuntu),
which does not do graphics, etc., so there is another reason to not do it.

===========================================================================
2020-11-03
Tuesday, November 03, 2020

The segfaults when compiling the mips kernel happens for any platform. It
seems like it is some sort of gcc error, not an error with this codebase.
If the build is restarted, then it will make more progress and end up built
eventually.


Copied over the sys/pic32 directory to sys/stm32. Only kept the max32
platform directory, as that one is proven with VirtualMIPS. I am aiming to
make a minimal kernel with this, that still works on VirtualMIPS. From
there I will make changes to get it to compile for Arm. Note that this is
just a copy of what is already there.

I am just working on the kernel right now. The userland will have to wait.
This makes the whole MACHINE{,_ARCH} stuff not work properly (until I get
all the arm-specific directories made). The way around this is to make a
mips userland, and then cd into the kernel build directory and compile a
kernel from there.


I chose the naming convention of the arm/stm32 kernels to be based off the
board name. I am first targeting the long-lived STM32F4DISCOVERY board
(replaced by the STM32F407G-DISC1). The kernel will be called f4discovery.
Future platforms will follow this convention (throw away the STM32 from the
start of the name, as it is obvious since it's in the sys/stm32 directory).

I renamed the max32 directory in stm32 to f4discovery. I changed some
references to max32 to now use f4discovery. I also temporarily changed the
config file for VirtualMIPS to now use the f4discovery kernel, just so I
can get a minimal kernel made. After that I will switch it back to max32.
I got to get qemu-arm to work with booting an Arm kernel once I'm there.


I figured out (by reading old RetroBSD commits) that the tools/configsys
program is no longer used. This is a good thing since it is the only C++
code in the tree. I may remove it later on. Since tools/configsys isn't
used, then that means that tools/kconfig is the kernel configurator.

I have noticed that compiling the kernel is much more involved than I
initially expected. The program kconfig is used to generate the Makefile
and other build files used in the kernel compilation process. There is a
document at http://retrobsd.org/wiki/doku.php/doc/kconfig that describes
the process somewhat. It seems to be flatout copy-pasted from the original
version for 4.4BSD, with a hacked up search and replace to add in the PIC32
and MIPS stuff. I will have to figure out if it is good information, or out
of date. I may need to modify kconfig for stm32 and arm. Hopefully not.


Okay, the kernel is configured by the file Config in the build directory.


I'm working on building the kernel, and trying to change the Config file
and have it still work. Trying to find a minimum file that still works and
runs on the VirtualMIPS simulator.

BUG: Not specifying a 'board' in Config causes kconfig to segfault.

I am focusing on the files Config, Makefile.kconf, devices.kconf,
files.kconf, and possibly others.

Working on a commit that removes many drivers that are not needed to make a
minimal kernel in the sys/stm32 directory. Some config lines in Config have
the words "optional" for them (such as sd or uart), but you have to have
them or else the kernel won't compile. I'll have to look into that more.

I put the machine/usb_uart.h include inside the UARTUSB_ENABLED ifdef, so
that it isn't a dependency.

I got rid of these drivers for a minimal kernel:
adc, glcd, gpanel*, gpio, kbd, mrams, picga, pwm, sdram, sramc, sdramp,
skel, spirams, usb, usbuart, and probably more.

Note that this is temporary. It will be nice to have common drivers for all
these devices, but right now I am focusing on getting an Arm kernel to run.

===========================================================================
2020-11-07
Saturday, November 07, 2020

I have tried to get gdb to work with VirtualMIPS to step through init code,
but I haven't had any luck. VirtualMIPS forever loops waiting for gdb, but
never connects. I also have not been able to make a mips-elf-gdb, so that
could also be a reason (I'm using the regular gdb, which is for amd64).


Making a commit that makes the stm32 port to compile with the arm-none-eabi
toolchain.
I converted the MIPS_GCC_PREFIX variable to ARM_GCC_PREFIX.
Trying out these arm compile options.

Building the kernel currently fails, as it is trying to build MIPS assembly
code in files such as startup.S.

The current options used allows many of the kernel files to compile. There
are a few that cannot compile, due to MIPS assembly code in machine/io.h.
Also, some other files cannot compile due to assembly inside their C code
or some other thing, such as init_main.c, kern_sig2.c, sys_pipe.c,
vm_sched.c, and spi_bus.c.

Linking has not yet been tried.

===========================================================================
2020-11-08
Sunday, November 08, 2020

Did some cleaning up of warnings in the kernel code. The BSD developers
have used the term Kernel Normal Form, or knf, for specifying the style of
kernel code. The manpage style(9) on OpenBSD has all the specifics.

Fixed some indentation, added some ints for implicit ints, and replaced
some utf-8 characters with ascii ones.


label_t needs to be defined for arm. Building the kernel keeps erroring on
needing a label_t. I think this is for setjmp() and longjmp(), which will
need to be written in arm assembly.

I edited sys/include/types.h to have an arm-specific typedef of label_t
(#ifdef __arm__ is what I used to guard it). It is currently an unsigned
val[11], based on what the mips one is, and what NetBSD, and other code,
has. But they have it as an int, not as an unsigned, so I will have to
research a bit more about what label_t is used for. Also, the mips version
shows the registers it uses, so I can go from there. There is a comment
that label_t is used by setjmp and longjmp.

Spent some time looking at how OpenBSD and NetBSD deal with setjmp() and
longjmp() in assembly. This spills over into the label_t struct and the
size of it, and which registers need to be saved and restored for setjmp()
and longjmp(), but also in general for all calling conventions.
This has led me to find the Arm document about Procedure Call Standard for
the Arm Architecture (AAPCS). There are a couple other documents I need to
read as well, such as the ELF for the Arm Architecture (AAELF) and the ABI
for the Arm Architecture Base Standard (BSABI). I don't think I need to
concern myself yet about the C++ ABI for the Arm Architecture (CPPABI), as
running C++ code on DiscoBSD would be a long term project. I may need to
read the Arm Architecture Reference Manual (ARMARM), but I am not sure if
this applies to Arm v7-m for Cortex or not.
This is all very confusing at the moment.

Read first half and skimmed through the AAPCS document. I think it is meant
more for assembler and complier writers than for those implementing an OS.
I have started to read RM0090, the 1749-page reference manual for STM32F407
devices (among others). Woof.


Okay, I made a small discovery about syscalls in Unix and how Arm deals
with them.
There are two types of calling conventions for Arm: APCS and TPCS.
These stand for "Arm Procedure Call Standard" for Arm calls, and "Thumb
Procedure Call Standard" for the 16-bit Thumb assembly language commands
that are exclusively used on the Cortex-M4 chips (among others).

I was looking at OpenBSD and NetBSD Arm code as a reference for the whole
label_t type for setjmp()/longjmp(), but that code is for Arm Mode assembly
language, not Thumb Mode assembly language. Even code that is for Cortex-A
chips uses Arm Mode, so none of that code can be directly used for insights
or ideas.

I still do not know if it is correct to use the Thumb Mode registers list
for label_t for setjmp()/longjmp(), but I am thinking that it is what is
right to do. I will have to look into it more, though.


For reference, here are the APCS and TPCS:

APCS - Arm Procedure Call Standard
============================================================
Reg | Name  | APCS Role
------------------------------------------------------------
r0  | a1    | Argument 1 / Scratch Register / Result
r1  | a2    | Argument 2 / Scratch Register / Result
r2  | a3    | Argument 3 / Scratch Register / Result
r3  | a4    | Argument 4 / Scratch Register / Result
r4  | v1    | Register Variable
r5  | v2    | Register Variable
r6  | v3    | Register Variable
r7  | v4    | Register Variable
r8  | v5    | Register Variable
r9  | sb/v6 | Static Base / Register Variable
r10 | sl/v7 | Stack Limit / Stack Chunk Handle / Reg. Var.
r11 | fp/v8 | Frame Pointer / Register Variable
r12 | ip    | Scratch Reg. / New-sb in inter-link-unit calls
r13 | sp    | Lower end of the current stack frame
r14 | lr    | Link Register / Scratch Register
r15 | pc    | Program Counter
------------------------------------------------------------

Note that for APCS OpenBSD saves r4-r14 for setjmp() and longjmp(), so
label_t is a "long val[11];" for 11 registers.


TPCS - Thumb Procedure Call Standard
============================================================
Reg | Name    | TPCS Role
------------------------------------------------------------
r0  | * a1    | Argument 1 / Scratch Register / Result
r1  | * a2    | Argument 2 / Scratch Register / Result
r2  | * a3    | Argument 3 / Scratch Register / Result
r3  | * a4    | Argument 4 / Scratch Register / Result
r4  | * v1    | Register Variable
r5  | * v2    | Register Variable
r6  | * v3    | Register Variable
r7  | * v4/wr | Reg. Var. / Work Reg. in func. Entry/Exit
r8  | (v5)    | (ARM v5 register, no defined role in Thumb)
r9  | (v6)    | (ARM v6 register, no defined role in Thumb)
r10 | sl(v7)  | Stack Limit
r11 | fp(v8)  | Frame Pointer (Usu. not used in Thumb state)
r12 | (ip)    | (ARM ip register, no defined role in Thumb)
r13 | * sp    | Stack pointer (full descending stack)
r14 | * lr    | Link Register
r15 | * pc    | Program Counter
------------------------------------------------------------

Registers r0 to r7 are named the Low Registers.
Registers r13 to r15 are named the High Registers.
(Some references name r8 - r15 as the High Registers).

Note that r12 may be used as a temporary register on Thumb function
Entry/Exit.


Comparing the TPCS to the APCS, I reckon that label_t should be a
"long val[6];" for r4-r7, r13, r14. Or maybe it will be an unsigned int;
whichever can hold a 32-bit register value.


Looked into how Newlib does setjmp()/longjmp() and that they use an int
array (called jmp_buf) by default, so I will too.
They also preserve many registers for arm: 23 ints in an array.
The registers are: v1-v7, fp, ip, sp, lr, f4, f5, f6, f7 which are callee
preserved registers. I was only saving six registers: v1-v4, sp, lr
(r4-r7, r13, r14), but I might end up changing my mind.

Looks like there is no code in RetroBSD that uses wchar_t, except in the
compiler (and other tools), so I won't need to worry about those floating
point registers (f4-f7) for now. I am fine with that, as top priority is to
just get it to work at all. Getting those applications to work is very far
down on the list, especially as they are MIPS-specific tools.


Thinking some more, I came up against the whole APCS vs TPCS issue again.
Previously I had determined that I need to follow the TPCS as far as any
assembly language goes and for setjmp()/longjmp(). I was reading a bit from
the book ARM Assembly for Embedded Applications, 5E by Daniel W Lewis who
is a professor at Santa Clara University in the School of Engineering. In
the book he says to use AAPCS. The book is written with a focus on an
STMF429I-DISC1 board, which is a Cortex-M4F processor (that does not
support ARM assembly; only supports thumb/thumb-2 instructions). I
purchased the book.

Looking at the APCS and TPCS, the registers overlap, so it can't hurt that
much if I just follow the APCS (at least for setjmp()/longjmp()) as it is a
superset of the registers used for TPCS.


Big discovery here.
I have come to the conclusion that the *AAPCS* is the current and only
Procedure Call Standard for ARM processors, and all previous standards are
obsolete. Note the difference between AAPCS, APCS, and TPCS. I was mixing
up APCS and AAPCS. If you look in the Terms and Abbreviations section in
the AAPCS it states that APCS and TPCS are "obsolete" and AAPCS is "this
standard", which is the current standard. Also a ATPCS (Arm-Thumb Procedure
Call Standard) is the "precursor to this standard" (meaning AAPCS) is also
*another* standard they came up with. I believe this is all due to changing
and improving Arm cores over its long lifespan.
It has been quite confusing sifting through all the Arm documents and which
standards are obsolete and which are current, and the crazy and almost
identical naming of each. Arm is quite a mess, to be honest.

In a way, this makes things easier and simpler for me. I can reference some
previous Arm code that also follows the AAPCS when I am looking for some
prior set precedent.


For reference, here is the AAPCS:

AAPCS - Procedure Call Standard for the Arm Architecture
============================================================
Reg | Synonym  | AAPCS Role
------------------------------------------------------------
r0  |   a1     | Argument 1 / Scratch Register / Result
r1  |   a2     | Argument 2 / Scratch Register / Result
r2  |   a3     | Argument 3 / Scratch Register
r3  |   a4     | Argument 4 / Scratch Register
r4  | * v1     | Variable Register 1
r5  | * v2     | Variable Register 2
r6  | * v3     | Variable Register 3
r7  | * v4     | Variable Register 4
r8  | * v5     | Variable Register 5
r9  | v6/SB/TR | Platform Register, defined by platform standard
r10 | * v7     | Variable Register 7
r11 | * FP/v8  | Frame Pointer or Variable Register 8
r12 |   IP     | The Intra-Procedure-Call Scratch Register
r13 | * SP     | The Stack pointer (full descending stack)
r14 |   LR     | The Link Register (Return Address)
r15 |   PC     | The Program Counter (Current Instruction)
------------------------------------------------------------

Uppercase register names are when they have a fixed role, else lowercase.

Registers r0 to r7 are named the Low Registers.
Registers r13 to r15 are named the High Registers.
(Some references name r8 - r15 as the High Registers).

A subroutine must preserve the contents of the registers r4-r8, r10, r11,
and SP (and r9 in PCS variants that designate r9 as v6).

So I have determined to use an array of eleven longs for label_t, for the
registers r4-r14 (v1-v8, IP, SP, LR). If this is wrong, then I will adjust
later on. More is better than less.

I have stumbled upon issues to deal with for exception handling, in regards
to which registers to save. That will be dealt with later on.

I will commit this for now. I have also added the AAPCS to a new "arm"
resources directory.

===========================================================================
2020-11-09
Monday, November 09, 2020

Copied over 002_led code from testing directory and put it into the kernel.
Got it to assemble, etc, and get a unix.elf and unix.bin file out of it. It
is able to run in the emulator and on the physical board. The linker script
was also copied over.

This is the first step into getting an Arm kernel to boot and run.

===========================================================================
2020-11-10
Tuesday, November 10, 2020

I had a meeting with Bill today about the progress of the directed study
and some steps for the future.

I need to specifically research how far an absolute jump can go, to be able
to determine if it is possible to run code from flash and have data in ram,
or have to have the whole kernel in ram (both .text and .data sections in
executable).
This information is required to make a proper memory map of the kernel and
where each section will go on the chip.


Learned that ARM has two stacks: one for the kernel and one for user
processes. This seems neat.

===========================================================================
2020-11-11
Wednesday, November 11, 2020

Still not sure if I have to use the CMSIS code/library or not. I would like
to use it initially, and then phase it out (if that is possible).

I have determined that at specific times STM or Arm released code with a
3-clause BSD license, but then changed it to either a 5-clause license or
the Apache 2.0 license. Also, the supplied linker scripts have an extremely
unacceptable license of two flavours: one flavor is where you must only use
it with the Atollic TrueSTUDIO product, and the other flavour where it flat
out restricts distribution of the file (how is it included with the STM
code packages then?) and that only registered System Workbench for MCU
users may distribute build outputs that use the linker script only if it
was built with forementioned toolchain.
Seems like some digital archaeology will be required to sort this all out.
It would be best to keep all of the codebase using the same permissive
BSD-style license.

I am thinking that I need two separate linker files: one for the kernel
(inside the kernel configuration directory), and one for userland programs
(inside the src directory). I will have to research this more. I am not
focusing on userland at the moment, in any case.


Started working on a new testing directory for 003_cmsis, which is to get a
basic executable to work with the Arm CMSIS headers, namely core_cm4.h, and
all the supporting headers like cmsis_gcc.h, etc. It has been hard to get
any of the template code from STM to work without using the bloated HAL
library. There *has* to be a way to have a minimal example without using
50 or more library files.

===========================================================================
2020-11-12
Thursday, November 12, 2020

STM vendor-supplied code is a bit of a disaster. Not as bad as Arm's very
disorganized technical documentation, though.
I have been keeping a personal public GitHub repo of all of the STM32F4
code that STM has released in the Cube package. This allows me to easily
sift through what has changed between releases with 'git diff'.

===========================================================================
2020-11-13
Friday, November 13, 2020

In a really old thread on the RetroBSD forums someone proposed the idea for
RetroBSD on STM32F4DISCOVERY, which is what I am doing. I found no evidence
of anyone actually making a port to ARM, though. Serge (lead developer of
RetroBSD) made a list of about a dozen items that he says that would need
to be done to port to the STM32.

This is the list of items to be done for an ARM port, from Serge V:
- Most of kernel is arch-independent (sys/kernel, sys/include) ==> There is
  a small number of places where a saved stack frame is directly referenced
  (look for u.u_frame), it needs #ifdef guards.
- Make sys/stm32 like sys/pic32.
- Use sys/pic32/baremetal/Makefile config as starting point.
- Make copies of arch-dependent files from sys/pic32 to sys/stm32 and
  modify them:
    cpu.h, io.h, limits.h, machparam.h, startup.S, clock.c, cons.c,
    devsw.c, exception.c, machdep.c, mem.c, signal.c, sysctl.c.
- Design memory map and linker script.
- Design user/kernel API: how to pass args to syscalls and get returned
  data. ==> Build syscall library at src/libc/thumb2/sys (maybe arm instead
  of thumb2).
- Port assembler files from NetBSD or OpenBSD.
- MPU used to protect kernel data region from user programs.

Some of these things I have already done, and some I am working on. This is
a good list to use as a guide.

===========================================================================
2020-11-14
Saturday, November 14, 2020

The stm32f407 memory organization is as follows (datasheet):
* Program memory, data memory, registers and I/O ports are organized within
  the same linear 4 Gbyte address space.
* The bytes are coded in memory in little endian format. The lowest
  numbered byte in a word is considered the word's least significant byte
  and the highest numbered byte, the word's most significant.
* 192KB total SRAM:
    112KB main internal SRAM1. I-bus, D-bus, S-bus.
    16KB auxiliary internal SRAM2. S-bus.
    64KB CCM (core coupled memory) data RAM. D-bus.
* 1MB of flash memory. I-bus, D-bus.

Different busses:
* I-bus: Instruction bus. Used to fetch instructions. The target of this
         bus is a memory containing code.
         (Internal Flash memory ICODE / SRAM1).
* D-bus: Data bus. Used for literal load. The target of this bus is a
         memory containing code or data.
         (Internal Flash memory DCODE / SRAM1).
* S-bus: System bus. Used to access data located in a peripheral or in
         SRAM. The targets of this bus are the internal SRAM1 and SRAM2,
         and peripherals.
         (SRAM1, SRAM2).

The SRAM1 and SRAM2 are aliased by bit-banding. I will need to investigate
this, since I do not understand it yet.

The 64KB CCM data RAM is *not* part of the AHB bus matrix, and can only be
accessed through the CPU (via the D-bus, but not through the bus matrix).

STM32F407VG memory map:

  1MB Flash:    0x0800 0000 - 0x080F FFFF

 64KB CCM SRAM: 0x1000 0000 - 0x1000 FFFF
112KB SRAM1:    0x2000 0000 - 0x2001 BFFF
 16KB SRAM2:    0x2001 C000 - 0x2001 FFFF

Note that 0x0000 0000-0x000F FFFF is aliased to Flash depending on the
BOOT pins. All the linker scripts I have found use 0x0800 0000-0x080F FFFF
as the Flash section.

Boot pins on the STM32F4DISCOVERY board (from board datasheet) are:
BOOT0: ON  (held low by a 510 ohm pull-down resistor)
BOOT1: OFF (held high by a 10 Kohm pull-up resistor)
This selects the main flash memory as the boot space.

The CPU fetches the top-of-stack value from address 0x0000 0000, it then
starts code execution from the boot memory starting from 0x0000 0004.

There is an embedded bootloader inside the STM32 chip, which will load the
hex or binary file into the flash of the chip. I do not need to concern
myself with how the bootloader does its work. It doesn't apply to DiscoBSD.

I do not know 100% about this yet, but I am suspecting that having kernel
ram in the 64KB CCM data ram is best, and use the 112KB SRAM1 for
applications. Perhaps there is not a use for the 16KB SRAM2 at the moment
(it only uses the S-bus).

Note that the CCM is not executable data memory. SRAM must be used for
that. If I end up getting a Hard Fault with the IBUSERR flag set, then
trying to execute from CCM is why.

The PIC32 that RetroBSD uses has only 128KB of ram and 512KB of flash.
There is no kernel executable ram.  All user ram is executable.
  192KB Kernel Flash
  320KB User Flash
  32KB Kernel RAM
  96KB User RAM

Those specs seem to fit really well with the STM32F4 that I am using for
DiscoBSD. Excellent.
Looks like I will use something like the following:
    1MB Kernel Flash
   ??KB User   Flash (Not sure what this is used for)
   64KB Kernel RAM
  112KB User   RAM

I may set up the flash following the situation with RetroBSD and have 192KB
for the kernel, and the rest for user flash. I wonder if I will need to set
up virtual addresses, in addition to the physical addresses. I need to
think about it.

===========================================================================
2020-11-15
Sunday, November 15, 2020

I spent most of the day working through all the sample project code from
STM or Arm.

I checked over all of the startup code for STM32F407 from ST and they are
all the same (file name startup_stm32f407xx.s).
The only difference is with ones that have some external RAM or other
external devices, then the startup code initializes them. I will reach that
point if/when I get there. No external devices yet.

The question now is "Do I use the ST code or the ARM code?". The startup
code requires that the linker script also be on the same wavelength,
insofar as the naming of ELF sections.

I am using the Makefile I made for an example project from a few years back
and I have modified it to work with the 003_cmsis code. Eventually I will
tie all the Makefiles together, once I know all the proper options, etc.

I have made a Frankenstein project out of 003_cmsis. I have used a template
code set from the Templates_LL for STM32F411RE-Nucleo in an older commit
from 2017-02-17 for STM32Cube_FW_F4_V1.15.0 in my repo for stm32cubef4
and I have an LED toggling inspired by the GPIO_InfiniteLedToggling_Init
Example Project for the same board. I have ported it to the board I am
using, which is the STM32F4-Discovery.

This code came with one of those encumbered linker scripts, so I got one
from the Arm Mbed OS project. I am not sure of its status, since it does
not have a license in the file. It may be the same 3-clause BSD-style
license as the assembly code and C code that comes with it, or in any of
its parent directories have. Or it may have the Mbed license, which is
Apache 2.0. Either way, I need to get on with it.
I edited the linker script a bit for consistency, information, and knf.

I changed all the files in testing/003_cmsis to Unix line endings by
running them through dos2unix.

The built executable (that is using the STM HAL LL low level library) can
run on the board through openocd and debugged with gdb. It blinks an LED.
The executable is 11440 bytes, which seems rather large for a blinking LED.

I will make notes about the low level library once I use it some more.

I added *.hex files to .gitignore for the testing directories.

===========================================================================
2020-11-16
Monday, November 16, 2020

I made a new testing directory called 004_nolibs, which will have as much
as a minimal example as I can make that is still useful. These means
blinking an LED. I have tried to not use the LL library (as can be guessed
with the directory name) but there is too much setup for the SysTick to not
use it.

It currently requires 25 files for a minimal example. Some of these could
be collapsed into one file (for example, main.h could be put in main.c) but
that makes them significantly different than what STM releases. This is
important, as if STM releases bug fixes, it would be nice to make straight-
forward patches. I might change my mind in the future, though.

It looks like a minimal example that uses the LL library needs to include,
at least, stm32f4xx_ll_{bus,rcc,system,utils}.h while ...pwr.h may or may
not be a fundamental header, and stm32_assert.h if you turn on assertions.

For STM- and Arm-specific files you have core_cm*.h, cmsis_gcc.h, the
startup_stm32f407xx.s assembly file (which requires a matching linker
script, i.e., STM32F407XG.ld), the standard STM include file stm32f4xx.h,
which includes stm32f407xx.h via build option -DSTM32F407xx, the system
files system_stm32f4xx.{c,h} that define the Arm-required SystemInit()
function among others, and lastly the files stm32f4xx_it.{c,h} that define
exception handlers and interrupt service routines.

To be concrete, here is the list of files for this testing code:
  Makefile
  STM32F407XG.ld
  cmsis_gcc.h
  core_cm4.h
  core_cmFunc.h
  core_cmInstr.h
  core_cmSimd.h
  main.c
  main.h
  startup_stm32f407xx.s
  stm32_assert.h
  stm32f407xx.h
  stm32f4xx.h
  stm32f4xx_it.c
  stm32f4xx_it.h
  stm32f4xx_ll_bus.h
  stm32f4xx_ll_gpio.h
  stm32f4xx_ll_pwr.h
  stm32f4xx_ll_rcc.h
  stm32f4xx_ll_system.h
  stm32f4xx_ll_utils.c
  stm32f4xx_ll_utils.h
  system_stm32f4xx.c
  system_stm32f4xx.h

Now, a more interesting part of this testing code is that it does not
include libc (which I reckon is newlib) by using the -nostdlib flag. This
brings the binary size down from 11440 bytes to 1712 bytes. Static
constructors (I imagine are for C++) must not be called, so I commented out
this line:
  bl __libc_init_array
in the startup assembly code in the startup_stm32f407xx.s file.
The testing code runs fine on the hardware. I have yet to test it in the
emulator, though. I am not sure if I need to keep the libc around for qemu
to work or not. I don't think I need to worry about a semihosted
environment right now.

I will be incorporating this testing code into the startup of the kernel. I
feel like this is a good start, and that I can start filling in the Unix
startup sequence from there.

===========================================================================
2020-11-17
Tuesday, November 17, 2020

I imported the testing/004_nolibs files into the sys/stm32 directory, and
edited the build Makefile to compile these files via the kernel build
facilities. I am able to build the blink example, and have it run on the
board through openocd and gdb. The Config file is still mainly for pic32,
as kconfig will need to be edited so that it can create stm32-specific
files, i.e., ioconf.c and those files need to be modified for stm32.

The Makefile does not yet use the -nostdinc flag, but it uses -nostdlib.
The files core_cm4.h and stm32f407xx.h include stdint.h, which is not
available if the -nostdinc flag is used. I'll have to think about the right
way to solve this.

===========================================================================
2020-11-18
Wednesday, November 18, 2020

I see that newlib and OpenBSD kernel have quite the rigamarole to get to
the actual fixed-width types for stdint.h and so I think it is not that
important to get -nostdinc working right now. Having the compiler pull from
newlib is fine enough for me at the moment.

===========================================================================
2020-11-19
Thursday, November 19, 2020

Just some notes about executable startup running directly on hardware:
* All execution starts at ENTRY(label) in the linker script. "label" is the
  assembly language label or function name that is where you start from a
  reset event.
* In Arm Cortex-M4 (and maybe others) the first 32 bits (first word) of the
  executable is actually the address of the stack pointer, and the second
  word is the address of the "label" label. This is handled by the linker.
* The default label in the vendor-supplied startup code is "Reset_Handler".
  The RetroBSD mips code has "_reset_vector_". OpenBSD Arm code has
  "bootstrap_start". Normally this label is called "start" or "_start" if
  the CPU is already set up. It is done in the assembly code file locore.S
  or locore0.S in OpenBSD.
* The next step is to copy the .data segment from the flash into RAM. This
  is the area between the symbols _sidata (start address for initialization
  values of the .data section) and _edata (end address for .data section).
  The .data segment is for initialized data.
* Next step is to zero out the .bss segment, by filling it with zeros.
  The .bss segment is for uninitialized variables/data.
* In the vendor-supplied code the next step is to call SystemInit, which is
  a default part of Arm CMSIS. It is defined in system_stm32f4xx.c and its
  main purpose is to set up the CPU clock. The variable SystemCoreClock is
  set to the CPU frequency, which can be used in user application code for
  the SysTick timer.
* The next call in the vendor-supplied code is to call __libc_init_array,
  which is for C++ ctors/dtors, which is none of our concern. I have that
  call commented out in startup_stm32f407xx.s, but I have yet to remove the
  matching symbols in the linker script (all the init / fini symbols).
* The final part of the startup sequence is the call to main() from the
  startup_stm32f407xx.s file. The main() function is in kernel/init_main.c
  and is the start of execution of the Unix kernel proper.

* Once init_main.c is running, then machine-dependent (MD) startup is run
  via the call to startup(), which is defined in the stm32/machdep.c file.
* After this, we are now in Unix kernel territory. kconfig() is run to
  configure machine-dependent (MD) peripherals that are specified in the
  kernel configuration file Config.
* I will go into depth later on how the kernel gets set up to run multi-
  process. But to make it quick, process 0 (the swapper) is handmade, but
  it is not called until later. First, all the machine-independent (MI)
  code will run, which consists of setting up signals, queues, the kernel
  clock, mounting the root filesystem, setting up the swap file, and
  setting up the root filesystem.
* Now process 1 (init) is made via the kernel-specific fork called newproc.
  The parent of the fork is pid 0 (the swapper) and the child is pid 1 (the
  init process). The swapper calls sched(), which never returns. sched() is
  defined in kernel/vm_sched.c and is the main loop of the scheduling
  process. The init process is not started yet from the newproc() fork; it
  is just continuing execution in main(). It sets up the process struct for
  init, copies it from icode into RAM at USER_DATA_START location (defined
  in the file stm32/machparam.h and seems to be located right after the
  kernel ram), and then finally main() returns, which goes to location 0 of
  user init code that was just copied out. Now we have got to user-land.

* I am having a hard time finding exactly where and/or how /sbin/init is
  started. Wait, I have found some information on it, but it is still not
  totally clear. In the RetroBSD mips code, the file startup.S has some
  assembly code that hardcodes the string "/sbin/init\0" as well as its
  options, and there is a syscall to 11, which I believe is SYS_execv.
  This whole thing comes about due to the bcopy(src, dst, nbytes) code in
  main(), which is bcopy(icode, USER_DATA_START, icodeend - icode). There
  is an extern const char icode[] in systm.h, which I am understanding is
  basically the argv for /sbin/init, and it is populated in startup.S.
* Note that the init process struct is still there in ram after the bcopy()
  and this is not a brand new process. Unix is interesting in how they have
  separated fork and exec from each other. Just to recap, the init process
  is as follows: pid 0 forked by calling newproc(), then the child process
  pid 1 (for init) sets up its process struct p, then bcopy() itself to the
  user ram area at USER_DATA_START with a specially crafted argv (icode),
  then main() returns 0 which goes to USER_DATA_START and we are running in
  user-land now. (I am not really sure about how the return 0 from main()
  gets you to user data start area in ram, but I will figure it out later).

===========================================================================
2020-11-20
Friday, November 20, 2020

I have been working on a significant commit for the last few days. Its
purpose is to transition from the blinky code running with using the kernel
build functions to where that code is a part of the kernel proper.
This commit is quite dirty, with many lines commented out with XXX. These
lines are mostly the mips assembly code in stm32/io.h. I also incorporated
the clock setup code from main.c into stm32/machdep.c. Some mips symbols
were conflicting with the STM vendor-supplied code, so I renamed the mips
symbols to something else (as it will all be stripped out eventually
anyways). These symbols were DEVID and TRISE.

I edited Config and Makefile.kconf to generate a proper build Makefile that
will use these new stm32 files. A hack in the Config file is to have two
"cpu" config lines; one for PIC32MX7 and one for STM32F407xx, as both of
these -D defines are needed to build the code.

All in all, I can fully build all the kernel code and the vendor-supplied
startup code. This code does *not* work right now, as it will not link.
There is much work to be done to get proper symbols in place for linking to
work. Namely, u and u0 defined symbols and ram area in the linker script.

I also added a missing int parameter for gsignal in kern_sig.c, and an Arm
define in sys_pipe.c. The define is XXX'd out right now. Hacky, for sure.

===========================================================================
2020-11-21
Saturday, November 21, 2020

These are the current "undefined references" that are stopping the kernel
from linking: u, u0, icode, icodeend, initflags, setjmp, longjmp
These symbols seem to only be present in the linker script in the mips code
so I can assume I need to get them into my linker script.

===========================================================================
2020-11-22
Sunday, November 22, 2020

Interesting thing I discovered about setjmp()/longjmp() and the label_t and
the jmp_buf. I previously neglected to understand that there is a setjmp()
in the standard C library, and a different setjmp() in the kernel.
longjmp() in the kernel was previously called resume() in 2.9BSD. Looks
like the 2.11BSD sources have the ENTRY(resume) label right after the
ENTRY(longjmp) label in the sys/pdp/mch_xxx.s file.

So I have determined to use an array of ten longs for label_t, for the
registers r4-r10, r11, r12, r14 (v1-v7, FP, IP/SP, LR). This may be wrong,
but it is what newlib does. Note that SP is copied into IP before IP is
saved. Who knows if this is correct, but I am running with it. Newlib is
the only precedent here.

So I have made incredible progress today. I now actually, truly, have code
running in the kernel. I have blinky code inside the startup() function,
which is called from main(), to run. I have it running through gdb on the
dev board.

The locations and sizes of u0, u, and RAM in the linker script will need to
be adjusted. I used the numbers that the mips port uses (32k RAM, 3K for
each of u0 and u).

A new setjmp.S file is made, which is the setjmp.S from newlib. I will
clean this up later, or just rewrite it altogether. At the end of this file
I have added the handwritten startup icode code for /sbin/init. It is not
working at the moment since the old mips code is commented out. I cannot
test this until I get an SD card driver to work, and a userspace with a
file system. The icode code is present mainly to get to the symbols so that
the kernel can link.

Current size of the executable is:
   text    data     bss     dec     hex filename
  82380     296   24016  106692   1a0c4 unix.elf

setjmp.S and "kconfig -g" was added to Makefile.kconf, and the Makefile in
the f4discovery directory was regenerated. -g is for debugging symbols in
the executable, which helps greatly when using gdb.

It has been a good day. A great milestone has been achieved.

===========================================================================
2020-11-23
Monday, November 23, 2020

Here is an interesting morsel of information: if you create a variable in a
Makefile and add a comment at the end of it, then that variable *includes*
the space between the variable and the comment hash #. For example:
  MACHINE_ARCH		?= arm    # 'arm' or 'mips'
will include the four spaces after arm in the variable MACHINE. It will
end up as "arm    " for MACHINE_ARCH. So when you do something like:
  ifeq ($(MACHINE_ARCH), arm)
    ...
  endif
it will never match. Ask me how I know! (I spent at least an hour on this).
I used that idiom in all the Makefiles and the *.mk included Makefiles. It
is fixed now in the next commit.

The build now defaults to MACHINE=stm32 and MACHINE_ARCH=arm. This can be
selectively chosen on the command line when you invoke make, like this:
  $ cd discobsd
  $ MACHINE=pic32 MACHINE_ARCH=mips gmake
and that will build the original mips code (which still works).

I have also selectively picked which version of yacc is used, depending on
the host OS. This information is obtained from "uname -s", which prints the
operating system's name. The version of yacc needed to compile the sources
is the BSD version. On BSD-style operating systems, this is just "yacc" but
it is called "byacc" on Linux (and maybe others). Normally yacc is actually
bison on Linux, which is incompatible with old BSD yacc.

I returned the file for VirtualMIPS to the default pic32/max32/unix.bin, as
I am now compiling the kernel for Arm, not for mips (as I did initially to
get a minimal set of drivers for a working kernel).

This commit is the start of working on userland. There still are many
issues to deal with, namely the required Arm-specific directories for
src/libc/arm and src/startup-arm and all the subdirectories there. Mainly,
crt0.c, and the rest of MD libc.

I will be going through lots of the code in src/ and cleanup implicit int
and other basic fixes that the newer version of gcc picks up (7.4.1 for Arm
gcc vs 4.8.1 for mips).

I also need to start on the report here soon. The biblography is getting a
bit long already.


Added Linux-specific prefixes for Arm toolchain, which is at /usr/bin,
whereas OpenBSD has it at /usr/local/bin.


Missed one use of byacc/yacc in tools/kconfig. Push a commit for that.

===========================================================================
2020-11-24
Tuesday, November 24, 2020

I emailed Bill about steps forward. I think I should get the report done,
and then write and test as much code as I can with the time remaining. It
does feel a bit lackluster as I have not "ported the Unix kernel" yet, in
the strictest sense.

I am building the userland and will document here all code that does not
build due to errors (I am turning off -Werror where I can, since there are
many implicit-int warnings, promoted to errors, in the build).
- startup-arm directory => startup directory
- src/libc/arm directory
- libcurses: scanw.c: _doscan() arg 3 incompatible type
- src/cmd/*: won't link
- src/games/adventure: init.c: linkdata function undefined behaviour
- src/games/*: won't link
- ./lib/crt0.o:
- ./lib/libc.a:
- ./lib/libm.a:
- ./lib/libcurses.a:
- ./lib/libgpanel.a:
- ./lib/libreadline.a:
- ./lib/libtermlib.a:
- ./lib/libwiznet.a:
- ./lib/retroImage:

So linking is the big deal so far with all the libraries. I need to get a
crt0.c or crt0.S working, as well as a userland linker script.

===========================================================================
2020-11-25
Wednesday, November 25, 2020

I feel like it is apt to write my report in troff. Well, I'll be using
groff. It just feels right,

===========================================================================
2020-11-26
Thursday, November 26, 2020

Looking up some resources on how to write reports with groff. I think I
will be using the ms macros.

===========================================================================
2020-11-28
Saturday, November 28, 2020

Added a bunch of resources for text processing in Unix. Mainly troff/groff
resources. There really isn't that much information on these tools.

Pushed a commit for the start of the report.

===========================================================================
2020-11-29
Sunday, November 29, 2020

Okay, getting a bibliography working with groff by using refer. I was using
some command line options, but I have added them to the troff file inside
the .R1 and .R2 macros at the top of the file.

The Makefile has been updated with the new build pipeline. This is it:
  $ refer -p ${BIB} ${REPORT}.ms | pdfroff -mspdf - > ${REPORT}.pdf

The setup for the report is kind of disgusting, and I am not really
satisfied with what I got. The main gripe is that the Table of Contents is
the first page of the PDF. It can only be first or last page (without some
sort of mangling by ghostscript). The good thing is that the TOC has links
to section headings. That is a nice touch. The TOC also does not show the
References page, which is a shame. I don't think I can fix that without
writing my own ms macros.
The order of the report is TOC, cover page, first page (with report info
from cover page), pages of the report, References page.
To get this, it requires .R1 .R2 macros at the start of the report (with
any options needed), .NH then .XN "Section title" for each section for the
linking to work. The end of the report needs to have these macros, in
order, for everything to work right: .bp .R1 .R2 .TC
The .bp is required to put the References on its own page.
The .R1 .R2 macros force the references to be written out at that moment.
The .TC at the end puts the TOC at the end of the report, but pdfroff moves
it to the start of the report.

Added the section on the Kernel Operation Overview to the report. It may be
too technical for the section. It may also be not deep enough to put in
other sections. We will see.

===========================================================================
2020-11-30
Monday, November 30, 2020

Fleshed out more of the System Startup section and the Bootstrapping and
Linker Script section. A trimmed down linker script is added in a code box.

===========================================================================
2020-12-05
Saturday, December 05, 2020

Lots has happened the last few days, but I have not documented all of it.
I am pushing a commit for .gitignore files that were somehow missed with
the initial commit of the RetroBSD repository. These are for the presence
of build directories where binaries are placed. The directories are:
/bin
/games
/games/lib
/libexec
/sbin

and each of these directories has a .gitignore that was missed. This
problem arised due to a fresh checkout of the repo on Winbuntu.

===========================================================================
2020-12-06
Sunday, December 06, 2020

I worked on an OpenBSD VirtualBox virtual machine for Bill to use to
evaluate this project. It came apparent quite fast that there is an issue
with my DiscoBSD repository. The specific problem is that the file expr.c
is not in my repository (as a file for certain programs, such as adb), but
it is in the RetroBSD repository. I will have to figure this out tomorrow.

The default install for OpenBSD is not sufficent for building gcc with the
Ports Collection. I should have made a separate /usr/ports partition for
building the ports, as the /usr partition was maxed out when compiling gcc.
I got it to compile and install, in any case, but it was not fun.

===========================================================================
2020-12-07
Monday, December 07, 2020

Ah yes, I found the culprits. Some .gitignore files in parent directories
have ignores that inadvertently trickled down to legitimate files in some
subdirectories. These include files: called expr.c; end in *.0 that are not
compiled man pages; named the same as a binary (morse).
I amended or added the .gitignore files to address this problem.
I still have the problem of the configsys program does not clean up from
the top-level Makefile. I do not believe that this program is used anyway,
so I will leave it for now.

The way I was able to find these missing/incorrect files is with:
  $ git status --ignored
It works pretty good.


If I compile with a command such as:
  $ MACHINE=pic32 MACHINE_ARCH=mips gmake -s >/dev/null
I am able to only see the errors of the build. These are:
* shift/reduce and reduce/reduce yacc errors
* on a fresh clone of repo, errors that files don't exist, like .oldversion
  which are files for the kernel. After the first build they are created.
* Segmentation faults in kernel/init_main.c that are from the mips gcc
  compiler. I won't address these anytime soon. Recompiling normally makes
  the compilation eventually complete. Note that the mips version is
  compiling a separate kernel for each target mips board. The only one I
  care about is the max32 board, as that is what runs with VirtualMIPS.

===========================================================================
2020-12-08
Tuesday, December 08, 2020

Worked on libcurses a bit, so that it would compile with arm-none-eabi-gcc.
Some implicit ints needed for K&R style function definitions. I had to do a
widesweeping change to the declaration of _sscans(). The last parameter was
an 'int *', but gcc said that it should be a 'va_list', so I changed it,
which forced me to change all the calls to it. I did not test the curses
code (I don't even know if it works at all), but it now compiles cleanly
with both the mips and arm gcc compilers.

Implicit int for cmd/init/init.c, and turn off -Werror in compiling adb and
adventure (too many warnings that are not relevant to fix).
