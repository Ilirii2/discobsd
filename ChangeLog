===========================================================================
2020-10-20
Tuesday, October 20, 2020

Started a ChangeLog file to keep track of my daily progress. I will need to
add in issues I have previously come up with and that which are not yet
included here.

I pushed a commit today of GPIO toggling (for the onboard LEDs) which goes
into great detail of each required part.
There are four registers to configure, in addition to configuring the RCC
clock. There are two ways to set or reset a GPIO pin once it is all set up:
by a read/modify/write dance, or with an atomic bit set or reset operation.

For setting up the GPIO (for port D, for the LEDs), this needs to be done:
 Set up the gpio:
1. clock through the RCC_AHB1ENR register.
2. mode through the GPIOD_MODER register.
3. output as push-pull or open-drain through the GPIOD_OTYPER register.
4. port speed through the GPIOD_OSPEEDR register.
5. pull-up or pull-down resistors through the GPIOD_PUPDR register.

For actually using the GPIO as an output there are two ways:
1. Read/modify/write of the GPIOD_ODR Output Data Register
2. Writing to the GPIOD_BSRR Bit Set/Reset Register

Whichever one is used (or available) is chip vendor dependent. These are
both available for STM32F4 chips.

I put the linker script in the testing base directory (with Makefile.inc)
so that all testing programs can use it, instead of having each program
duplicating the linker script.

The program I finished today has links to all the documentation I have used
to make that program. I will end up putting them in this repository.

I added a .gitignore to the testing directory. Not sure if it is best to
use a global one yet, so just this local one for now.

===========================================================================
2020-10-31
Saturday, October 31, 2020

Pushed two commits that import the RetroBSD repo into this project repo.
I also included the zip from the autobuilder so that there is some starting
point that is easily referenced (instead of just a commit id).


The last while I've been trying to get a mips-elf port of gcc, binutils,
and gdb to build the RetroBSD repo (which is mips-based). I had already got
it to work on Ubuntu (through the Windows Subsystem for Linux) by following
the instructions at http://retrobsd.org/wiki/doku.php/doc/toolchain-mips
which took quite a bit of time to go through.

Also, these instructions are made for an old version of gcc, compiled with
another old version of gcc. The newer gcc's are way more pedantic and find
so many more bugs, even small ones, so it has been a challenge. For
instance, one bug I came across was that glibc changed the location of some
defines into a different header, so I had to find out which one it was and
make a patch for it. It's not hard, just tedious and unfulfilling work.


Get first crack at a devel/mips-elf OpenBSD port done. It has gcc 4.8.1 and
binutils 2.27. Many patches were made. 8 for binutils, 19 for gcc.
I based this port on the ports devel/xtensa-elf and devel/arm-none-eabi.
gdb and newlib are not done yet (and maybe never will be).
binutils was the first I got working. It took a while to get gcc to work.

This port is for compiling the original code of RetroBSD on OpenBSD. The
original code targets the PIC32 MIPS-based microcontroller, thus mips-elf.

There are two or three segfaults in the process of building gcc. I have no
reason why, and I haven't investigated. Starting the build over again
allows a bit more progress until there is another segfault. I just kept
restarting it until the build is complete. The segfaults could be due to
running out of memory or something like that. Who knows. gcc is complex.

There are some post-patch and post-install fixes in the devel/avr/gcc
Makefile that need to be used. This will get rid of all the ridiculous
patches for the single space character needed by c++11 for variables.

===========================================================================
2020-11-01
Sunday, November 01, 2020

I started to build DiscoBSD with my new toolchain, but there are quite a
few errors. The main one is (after much investigation into the cause) due
to gcc not passing -msoft-float to the assembler. This caused the assembler
to assemble as -mhard-float. The linker wasn't able to link these two
separate types of objects.

I fixed this by getting a patchset from gcc, which I had to modify, as it
was meant for some newer version of gcc (5?).

I made 4 new patches, and added some more changes to an already existing
patch. That fixed the whole floating-point issue. The userland programs can
be built now. The kernel builds, too. There still is a problem with the
linker overlaying sections of the executable. I haven't researched it yet,
though.

The VirtualMIPS simulator isn't building. Probably due to not having the
libelf package on OpenBSD. I may need to port that library, too. Who knows.

Other problems are: elf2aout, manpages, init_main.c, expr, yacc kconfig
reduce/reduce conflicts, install not working.

I updated the README.md file for tools/openbsd to include how to get
binutils and gcc for the MIPS target.
