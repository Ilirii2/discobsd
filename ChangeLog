===========================================================================
2020-10-20
Tuesday, October 20, 2020

Started a ChangeLog file to keep track of my daily progress. I will need to
add in issues I have previously come up with and that which are not yet
included here.

I pushed a commit today of GPIO toggling (for the onboard LEDs) which goes
into great detail of each required part.
There are four registers to configure, in addition to configuring the RCC
clock. There are two ways to set or reset a GPIO pin once it is all set up:
by a read/modify/write dance, or with an atomic bit set or reset operation.

For setting up the GPIO (for port D, for the LEDs), this needs to be done:
 Set up the gpio:
1. clock through the RCC_AHB1ENR register.
2. mode through the GPIOD_MODER register.
3. output as push-pull or open-drain through the GPIOD_OTYPER register.
4. port speed through the GPIOD_OSPEEDR register.
5. pull-up or pull-down resistors through the GPIOD_PUPDR register.

For actually using the GPIO as an output there are two ways:
1. Read/modify/write of the GPIOD_ODR Output Data Register
2. Writing to the GPIOD_BSRR Bit Set/Reset Register

Whichever one is used (or available) is chip vendor dependent. These are
both available for STM32F4 chips.

I put the linker script in the testing base directory (with Makefile.inc)
so that all testing programs can use it, instead of having each program
duplicating the linker script.

The program I finished today has links to all the documentation I have used
to make that program. I will end up putting them in this repository.

I added a .gitignore to the testing directory. Not sure if it is best to
use a global one yet, so just this local one for now.

===========================================================================
2020-10-31
Saturday, October 31, 2020

Pushed two commits that import the RetroBSD repo into this project repo.
I also included the zip from the autobuilder so that there is some starting
point that is easily referenced (instead of just a commit id).


The last while I've been trying to get a mips-elf port of gcc, binutils,
and gdb to build the RetroBSD repo (which is mips-based). I had already got
it to work on Ubuntu (through the Windows Subsystem for Linux) by following
the instructions at http://retrobsd.org/wiki/doku.php/doc/toolchain-mips
which took quite a bit of time to go through.

Also, these instructions are made for an old version of gcc, compiled with
another old version of gcc. The newer gcc's are way more pedantic and find
so many more bugs, even small ones, so it has been a challenge. For
instance, one bug I came across was that glibc changed the location of some
defines into a different header, so I had to find out which one it was and
make a patch for it. It's not hard, just tedious and unfulfilling work.


Get first crack at a devel/mips-elf OpenBSD port done. It has gcc 4.8.1 and
binutils 2.27. Many patches were made. 8 for binutils, 19 for gcc.
I based this port on the ports devel/xtensa-elf and devel/arm-none-eabi.
gdb and newlib are not done yet (and maybe never will be).
binutils was the first I got working. It took a while to get gcc to work.

This port is for compiling the original code of RetroBSD on OpenBSD. The
original code targets the PIC32 MIPS-based microcontroller, thus mips-elf.

There are two or three segfaults in the process of building gcc. I have no
reason why, and I haven't investigated. Starting the build over again
allows a bit more progress until there is another segfault. I just kept
restarting it until the build is complete. The segfaults could be due to
running out of memory or something like that. Who knows. gcc is complex.

There are some post-patch and post-install fixes in the devel/avr/gcc
Makefile that need to be used. This will get rid of all the ridiculous
patches for the single space character needed by c++11 for variables.

===========================================================================
2020-11-01
Sunday, November 01, 2020

I started to build DiscoBSD with my new toolchain, but there are quite a
few errors. The main one is (after much investigation into the cause) due
to gcc not passing -msoft-float to the assembler. This caused the assembler
to assemble as -mhard-float. The linker wasn't able to link these two
separate types of objects.

I fixed this by getting a patchset from gcc, which I had to modify, as it
was meant for some newer version of gcc (5?).

I made 4 new patches, and added some more changes to an already existing
patch. That fixed the whole floating-point issue. The userland programs can
be built now. The kernel builds, too. There still is a problem with the
linker overlaying sections of the executable. I haven't researched it yet,
though.

The VirtualMIPS simulator isn't building. Probably due to not having the
libelf package on OpenBSD. I may need to port that library, too. Who knows.

Other problems are: elf2aout, manpages, init_main.c, expr, yacc kconfig
reduce/reduce conflicts, install not working.

I updated the README.md file for tools/openbsd to include how to get
binutils and gcc for the MIPS target.


Now I am trying to get VirtualMIPS to work. Most errors are about specific
types used. I am guessing they are defined in the libelf code.

I have had to (temporarily) hard-code some directory paths in the Makefile
for VirtualMIPS to what OpenBSD uses, such as /usr/local/include instead of
/opt/local/include on Linux.


Some cool things about the name DiscoBSD:
First, 'disco' is Latin for 'I learn' or 'to learn' or 'become aquainted
with' or 'I study, practice'. All of these definitions are quite in line
with the whole purpose of this directed study, which is to do a heck of a
lot of learning about Arm and about Unix and about early BSD.

Second, STM has a 'Discovery' line of demonstration and evauation circuit
boards with STM32F4 microcontrollers. I am targeting the STM32F4DISCOVERY
board with an STM32F407 chip (which does not have an MMU).

Third, it is just a great name. There is a nice ring to it. It has five
letters like 'Retro', and it gives you feelings of the old days in the 70s
when BSD had its beginnings.


Okay, ELF toolchain is needed to get VirtualMIPS to work. It can be used
instead of libelf. I am so glad I do not need to port another library.
ELF toolchain is available as a package on OpenBSD. I updated the README.

For VirtualMIPS, I initially put the pthreads header include into many,
many files. I then figured out that I only needed to have it in the mips.h
file, which is included in all those files. Seems like a better solution.


I got the build system so that it is possible to build RetroBSD (MIPS) on
OpenBSD. The changes were to update byacc to yacc, and add a check for the
mips-elf tools to the build Makefiles. OpenBSD has them installed in the
third-party location /usr/local/bin/mips-elf- .

Note that when I say "RetroBSD" I am talking about the original MIPS code.
"DiscoBSD" will refer to the Arm code/port I am writing.

I found that there is something wrong with elf2aout in that it fails on an
ELF section of type 70000003 in program header 1, from the error message.
I need to learn about the ELF executable file type and the a.out type.


I read about the ELF executable file type in the book Learning Linux Binary
Analysis and in the elf(3) and elf(5) manpages. There is not a lot of info
on it. All my C and Unix books don't really mention anything about it.

I am looking at the differences between the "adb" executables compiled on
OpenBSD, and on Linux (Winbuntu). This is one of the programs that fail to
convert from ELF to a.out by the elf2aout program, with this error:
elf2aout: Program header 1 type 70000003 can't be converted.
The program output of "readelf -aW adb.elf" is what is used to look at elf.

I determined, through using the readelf tool from binutils, that the MIPS
toolchain I made to work on OpenBSD adds a section to the executable called
.MIPS.abiflags, which is not made on the Winbuntu system. I believe this
section is made by the linker. I don't know for sure, but I believe that
this is due to my toolchain using modern versions of the depended-on
libraries, perhaps the BFD library. I found a post on a Clang/LLVM mailing
list that said they needed to add that particular section to MIPS exes.

What I did to fix this problem was add that section to the /DISCARD/ part
at the end of the linker script elf32-mips.ld . The line is:
  /DISCARD/ : { *(.MIPS.abiflags) }
inside the SECTIONS curly braces near the end of the file.

A small diff to fix a big problem.

Now, I am able to build the whole system, and actually run it on OpenBSD!
How I do it is, after the system is built, I go into the tools/virtualmips
directory and run ./pic32 and I get a shell, and I can log in as root
(without a password) and then run any command.

I included a screenshot of RetroBSD booting in the new 'report' directory.

I also noticed that this problem was happening with all linker scripts.
Bootloaders were having problems with overlapping sections due to the
addition of the .MIPS.abiflags section to the executable. I removed that
section from any binary made, by adding the /DISCARD/ line to all linker
scripts.

Found that seven of the target platforms for RetroBSD segfault upon
building init_main.c at the very last line. I can't get a stack trace as
libunwind isn't a part of the mips-elf gcc port I created. These target
platforms are not the popular ones for the MIPS port, so I am going to
leave them alone. The max32 port works, and that is what also works with
the VirtualMIPS simulator, so I will leave it for now.


The libintl library is used by VirtualMIPS. Add check for it on OpenBSD.
I don't think it is needed, but what the heck. Why not.

===========================================================================
2020-11-02
Monday, November 02, 2020

I discovered that there are quite a bit of hardcoded MIPS variables spread
throughout the codebase, mostly in the Makefiles. I will have to clean up
some more of the codebase before I can get started on the Arm port.

The first thing I have noticed is that the variable MACHINE is used for
mips, and I will need to make it set to either mips or arm. I can do
autoselection of build tools and specific kernel code by just using the
MACHINE variable. I have had a hard time finding out where that variable is
defined in OpenBSD (so that I can use a similar place in the build system
for DiscoBSD).


Cool fact: A comment in a Makefile is a comment, except for the odd fact
that if the line ends in a backslash, and that backslash is not escaped
with another backslash, then the comment will continue across multiple
lines. So don't think that a (#) comment is just a comment.


Okay, I'm working on a commit for all the Makefile business to have
multiple target architectures supported in this codebase.

I am temporarily turning off -Werror for now, as the new gcc is showing too
many errors, and I just want the build to be able to finish.


Researched a bit about how NetBSD does cross-compilation with build.sh and
I made a groundbreaking development. I need to introduce a MACHINE_ARCH
variable which will replace what is currently defined for MACHINE.
This will break compatibility with RetroBSD, but this is the right way of
doing it. This is also how OpenBSD does it with the macppc/powerpc arches.
I am glad I held off on that commit that would only add MACHINE.

Going forward, this will be the status of MACHINE{,_ARCH} variables:
MACHINE      specifies the machine hardware platform.
MACHINE_ARCH specifies the machine processor architecture.
For example: MACHINE => pic32 ; MACHINE_ARCH => mips
             MACHINE => stm32 ; MACHINE_ARCH => arm

MACHINE      derives from "uname -m"
MACHINE_ARCH derives from "uname -p"

For right now, the defaults are MACHINE=pic32 and MACHINE_ARCH=mips
The Makefiles use the "?=" instead of just a "=", so they can be redefined
on the command line when gmake is invoked, like this:
  $ MACHINE=stm32 MACHINE_ARCH=arm gmake

Not sure about the arm compiling lines in target.mk. I will refine the
options once I get it to compile for Arm. I copied over the linker script
from the testing directory and named it similar to the mips one. It will
definitely need to be changed.

Thought about if I should amend the Makefiles to also figure out which host
the cross-compilation is being performed on. I have come to the conclusion
that I won't do that, and I will focus my development work on OpenBSD as
the host development platform, and I could get the other OSes working after
I have the Arm port working. I also don't have a dedicated Linux install. I
only currently have the Ubuntu on Windows Subsystem for Linux (Winbuntu),
which does not do graphics, etc., so there is another reason to not do it.

===========================================================================
2020-11-03
Tuesday, November 03, 2020

The segfaults when compiling the mips kernel happens for any platform. It
seems like it is some sort of gcc error, not an error with this codebase.
If the build is restarted, then it will make more progress and end up built
eventually.


Copied over the sys/pic32 directory to sys/stm32. Only kept the max32
platform directory, as that one is proven with VirtualMIPS. I am aiming to
make a minimal kernel with this, that still works on VirtualMIPS. From
there I will make changes to get it to compile for Arm. Note that this is
just a copy of what is already there.

I am just working on the kernel right now. The userland will have to wait.
This makes the whole MACHINE{,_ARCH} stuff not work properly (until I get
all the arm-specific directories made). The way around this is to make a
mips userland, and then cd into the kernel build directory and compile a
kernel from there.


I chose the naming convention of the arm/stm32 kernels to be based off the
board name. I am first targeting the long-lived STM32F4DISCOVERY board
(replaced by the STM32F407G-DISC1). The kernel will be called f4discovery.
Future platforms will follow this convention (throw away the STM32 from the
start of the name, as it is obvious since it's in the sys/stm32 directory).

I renamed the max32 directory in stm32 to f4discovery. I changed some
references to max32 to now use f4discovery. I also temporarily changed the
config file for VirtualMIPS to now use the f4discovery kernel, just so I
can get a minimal kernel made. After that I will switch it back to max32.
I got to get qemu-arm to work with booting an Arm kernel once I'm there.


I figured out (by reading old RetroBSD commits) that the tools/configsys
program is no longer used. This is a good thing since it is the only C++
code in the tree. I may remove it later on. Since tools/configsys isn't
used, then that means that tools/kconfig is the kernel configurator.

I have noticed that compiling the kernel is much more involved than I
initially expected. The program kconfig is used to generate the Makefile
and other build files used in the kernel compilation process. There is a
document at http://retrobsd.org/wiki/doku.php/doc/kconfig that describes
the process somewhat. It seems to be flatout copy-pasted from the original
version for 4.4BSD, with a hacked up search and replace to add in the PIC32
and MIPS stuff. I will have to figure out if it is good information, or out
of date. I may need to modify kconfig for stm32 and arm. Hopefully not.


Okay, the kernel is configured by the file Config in the build directory.


I'm working on building the kernel, and trying to change the Config file
and have it still work. Trying to find a minimum file that still works and
runs on the VirtualMIPS simulator.

BUG: Not specifying a 'board' in Config causes kconfig to segfault.

I am focusing on the files Config, Makefile.kconf, devices.kconf,
files.kconf, and possibly others.

Working on a commit that removes many drivers that are not needed to make a
minimal kernel in the sys/stm32 directory. Some config lines in Config have
the words "optional" for them (such as sd or uart), but you have to have
them or else the kernel won't compile. I'll have to look into that more.

I put the machine/usb_uart.h include inside the UARTUSB_ENABLED ifdef, so
that it isn't a dependency.

I got rid of these drivers for a minimal kernel:
adc, glcd, gpanel*, gpio, kbd, mrams, picga, pwm, sdram, sramc, sdramp,
skel, spirams, usb, usbuart, and probably more.

Note that this is temporary. It will be nice to have common drivers for all
these devices, but right now I am focusing on getting an Arm kernel to run.

===========================================================================
2020-11-03
Saturday, November 07, 2020

I have tried to get gdb to work with VirtualMIPS to step through init code,
but I haven't had any luck. VirtualMIPS forever loops waiting for gdb, but
never connects. I also have not been able to make a mips-elf-gdb, so that
could also be a reason (I'm using the regular gdb, which is for amd64).


Making a commit that makes the stm32 port to compile with the arm-none-eabi
toolchain.
I converted the MIPS_GCC_PREFIX variable to ARM_GCC_PREFIX.
Trying out these arm compile options.

Building the kernel currently fails, as it is trying to build MIPS assembly
code in files such as startup.S.

The current options used allows many of the kernel files to compile. There
are a few that cannot compile, due to MIPS assembly code in machine/io.h.
Also, some other files cannot compile due to assembly inside their C code
or some other thing, such as init_main.c, kern_sig2.c, sys_pipe.c,
vm_sched.c, and spi_bus.c.

Linking has not yet been tried.
